# JavaScript 과제

## ★ JavaScript의 자료형과 JavaScript만의 특성은 무엇일까 ? 

### 느슨한 타입(loosely typed)의 동적(dynamic) 언어

* JavaScript는 느슨한 타입(loosely typed)의 동적(dynamic) 언어로 JavaScript의 변수는 어떤 특정 타입과 연결되지 않으며,<br>
모든 타입의 값으로 할당 및 재할당 가능합니다.


```js
let foo = 42 // foo : 숫자
foo = 'bar' // foo : 문자열
foo = ture //  foo : 불리언
```

### JavaScript 형변환

* 함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환됩니다. 이런 과정을 "형 변환(type conversion)"이라고 합니다.<br>
alert가 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여주는 것이나,<br> 수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가 형 변환의 대표적인 예시입니다.
<br>이 외에, 전달받은 값을 의도를 갖고 원하는 타입으로 변환(명시적 변환)해 주는 경우도 형 변환이라고 할 수 있습니다.

▷ 문자형으로 변환

문자형으로의 형 변환은 문자형의 값이 필요할 때 일어납니다.<br>
alert메서드는 매개변수로 문자형을 받기 때문에, alert(value)에서 value는 문자형이어야 합니다.<br> 만약, 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환됩니다.<br>
String(value) 함수를 호출해 전달받은 값을 문자열로 변환 할 수도 있습니다.

```js
let value = true;
alert(typeof value); // boolean

value = String(value); // 변수 value엔 문자열 "true"가 저장됩니다.
alert(typeof value); // string
```
false는 문자열 "false"로, null은 문자열 "null"로 변환되는 것과 같이, 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어납니다.

▷ 숫자형으로 변환

숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어납니다.

```js
alert( "6" / "2" ); // 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행됩니다.
```

Number(value) 함수를 사용하면 주어진 값(value)을 숫자형으로 명시해서 변환할 수 있습니다.

```js
let str = "123";
alert(typeof str); // string

let num = Number(str); // 문자열 "123"이 숫자 123으로 변환됩니다.

alert(typeof num); // number
```

숫자형 값를 사용해 무언가를 하려고 하는데 그 값을 문자 기반 폼(form)을 통해 입력받는 경우엔, 이런 명시적 형 변환이 필수입니다.<br>
한편, 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면, 그 결과는 NaN이 됩니다.

```js
let age = Number("임의의 문자열 123");

alert(age); // NaN, 형 변환이 실패합니다.
```

▷ 불린형으로 변환

불린형 변환은 논리 연산을 수행할 때 발생합니다.<br>
Boolean(value)를 호출하면 명시적으로 불리언으로의 형 변환을 수행할 수 있습니다.<br>
불린형으로 변환 시 적용되는 규칙은 다음과 같습니다.<br>
숫자 0, 빈 문자열, null, undefined, NaN과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 false가 됩니다. 그 외의 값은 true로 변환됩니다.

```js
alert( Boolean(1) ); // 숫자 1(true)
alert( Boolean(0) ); // 숫자 0(false)

alert( Boolean("hello") ); // 문자열(true)
alert( Boolean("") ); // 빈 문자열(false
```

※ 숫자형으로 변환 시 undefined는 0이 아니라 NaN이 되며,<br>
문자열 "0"과 " "같은 공백은 불린형으로 변환 시 true가 된다.

### ==, ===

* =='와 '===' 연산자의 주된 차이점은, 예를 들어, 숫자를 숫자 리터럴과 비교하면, '=='는 그것을 허용하지만,<br> 
'===' 두 변수의 형식은 동일하지 않은 경우, 값뿐만 아니라 두 변수의 유형도 확인하므로, 허용하지 않는 것이다. 즉,<br>
'==='는 'false'으로 반환하고, '=='는 'true'로 반환다.

▷ ==, ===의 차이점

'==' 연산자를 이용하여 서로 다른 유형의 두 변수의 [값] 비교<br>
'==='는 엄격한 비교를 하는 것으로 알려져 있다 ([값 & 자료형] -> true).

```js
✔ 0값은 false와 동일하므로 -> true 출력

0 == false // true 
✔ 두 피연산자의 유형이 다르기 때문에 ->false

0 === false // expected output: false 
console.log(typeof 0); 	// expected output: "number"
console.log(typeof false); // expected output: "boolean"
🔍 숫자와 문자열 비교
✔ 자동 유형변화 비교

2 == "2" // expected output: true
✔ 두 피연산자의 유형이 다르기 때문에 ->false

2 === "2" // expected output: false 
console.log(typeof 2);	// expected output: "number"
console.log(typeof "2");  // expected output: "string"
```

서로 호환되지 않는 두 변수를 비교하면 컴파일 오류* 를 일으키는 자바 평등 연산자(Java Equality 연산자)와 많이 비슷하다.

▷ null 와 undefined 비교했을 때의 결과

```js
✔ 자동 유형변화 비교

null == undefined // expected output: true
✔ 두 피연산자의 유형이 다르기 때문에 ->false

null == undefined // expected output: false 
console.log(typeof null);	// expected output: "object"
console.log(typeof undefined);  // expected output: "undefined"
```

▷ '!=' 와 '!==' 비교연산자의 차이

```js
✔ 값이 다르지 않음으로 (자료형 비교 안함)

2 != "2" // expected output: false
✔ 두 피연산자의 유형이 다른 것이 맞기 때문에 -> true

2 !== "2" // expected output: true 
console.log(typeof 2);	// expected output: "number"
console.log(typeof "2");  // expected output: "string"
```

### 느슨한 타입(loosely typed)의 동적(dynamic) 언어의 문제점과 보완할 수 있는 방법

* 실행 도중에 변수에 예상치 못한 타입이 들어와 타입에러가 발생할 수 있음
* 동적타입 언어는 런타임 시 확인할 수 밖에 없기 때문에, 코드가 길고 복잡해질 경우 타입 에러를 찾기가 어려워짐
* 이러한 불편함을 해소하기 위해 TypeScipt나 Flow 등을 사용할 수 있음

### javaScript undefined와 null

* 자바스크립트에는 '없음'을 나타내는 값이 두가지가 있습니다. 바로 undefined와 null 입니다.<br>
* 두 값의 의미는 같은 것 같지만 미세하게 다르고 사용하는 목적 또한 다릅니다.

▷ undefined

사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 있습니다.<br> 
사용자가 명시적으로 undefined를 지정하는 경우는 달리 덧붙일 내용이 없어 넘어가고, 자바스크립트 엔진이 자동으로 부여하는 경우에 대해 살펴봅시다.<br>
자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환합니다.<br> 
다음 세 경우가 이에 해당합니다.

값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때<br>
객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때<br>
return 문이 없거나 호출되지 않은 함수의 실행 결과

```js
var a;
console.log(a) // undefined

var obj = { a: 1};
console.log(obj.b) // undefined

var func = function() {};
var c = func();
conosle.log(c) // undefined
```

위의 1번째 경우처럼 값을 대입하지 않은 경우에 대해 배열의 경우에는 조금 특이한 동작을 확인할 수 있습니다.

```js
var arr1 = [];
arr1.length = 3;
console.log(arr1); // [empty x 3]

var arr2 = new Array(3);
console.log(arr2); // [empty x 3]

var arr3 = [undefined, undefined, undefined];
console.log(arr3); // [undefined, undefined, undefined]
```

arr1, arr2의 경우 [empty x 3]이 출력되지만 undefined로 초기화한 arr3의 경우 출력값 자체가 다른것을 확인할 수 있습니다.<br>
이처럼 '비어있는 요소'와 'undefined를 할당한 요소'는 출력 결과부터 다릅니다.<br>
'비어있는 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외됩니다. 

```js
var arr1 = [undefined, 1];
var arr2 = [];
arr2[1] = 1;

arr1.forEach(function (v,i)) { console.log(v, i); }); // undefined 0 / 1 1
arr2.forEach(function (v,i)) { console.log(v, i); }); // 1 1

arr1.map(function(v,i) { return v + i}); // [NaN,2];
arr2.map(function(v,i) { return v + i}); // [empty,2];

arr1.filter(function(v) { return !v; }); // [undefined]
arr1.filter(function(v) { return !v; }); // []

arr1.reduce(function (p,c,i) { return p + c + i },'' ); // undefined011
arr1.reduce(function (p,c,i) { return p + c + i },'' ); // 11
```
arr2의 경우 각 메서드들이 비어있는 요소에 대해서는 어떠한 처리도 하지 않고 건너뛰었음을 알 수 있습니다.<br> 
이러한 동작이 배열에서만 발견할 수 있는 특별한 현상인 것처럼 소개했지만, 사실은 배열도 객체임을 생각해보면 지극히 자연스러운 현상입니다.

undefined의 경우 그 자체로 값입니다.<br>
비록 '비어있음'을 의미하긴 하지만 하나의 값으로 동작하기 때문에 이때의 프로퍼티나 배열의 요소는 고유의 키값이 실존하며 순회의 대상이 될 수 있습니다.<br>
한편 사용자가 아무것도 하지 않은 채로 접근했을 때 자바 스크립트 엔진이 하는 수 없이 반환해주는 undefined는 해당 프로퍼티 내지 배열의 키값 자체가 존재하지 않음을 의미합니다.<br>
값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면 자바스크립트 엔진이 반환해주는 undefined는 무나 그대로 값이 없을음 나타내는 것입니다.

'var a' 라는 구문에 의해 식별자 a에 자동으로 undefined가 '할당된다'고 소개하는 것이 일반적입니다.<br>
그런데 자바스크립트가 실제로 그렇게 동작하는 것은 아닙니다. 정확히는 아무것도 할장하지 않고 끝나며,<br>
이후 변수 a에 접근하고자 할 때 비로소 undefined를 반환하는 것이 맞습니다.

▷ null

같은 의미를 가진 null이라는 값이 별도로 있는데 굳이 undefined를 써야 할 이유가 없습니다.<br> 
'비어있음'을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null을 쓰면 됩니다.<br>
null은 애초부터 이런 용도로 만든 데이터 타입입니다.<br>
이런 규칙을 따르는 한 undefined는 오직 '값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진지 반환해주는 값'으로서만 존재할 수 있겠습니다.<br>
null은 한 가지 주의할 점이 있는데 typeof null이 object라는 점입니다.<br>
이는 자바스크립트 자체의 버그로 어떤 변수의 값이 null인지 여부를 판별하기 위해서는 typeof 대신 다른 방법으로 접근해야 합니다.

```js
var n = null;
console.log(typeof n); // object

console.log(n == undefined); // true
console.oog(n == null); // true

console.log(n === undefined); // false 
console.log(n === null); // true
```

